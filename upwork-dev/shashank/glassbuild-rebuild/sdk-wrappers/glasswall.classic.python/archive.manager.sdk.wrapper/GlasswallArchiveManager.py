import ctypes as ct
import os


class GwMemReturnObj:
    """A result from Glasswall containing the return status along with the file buffer and report buffer"""

    def __init__(self):
        pass

    returnStatus = 0        # type: int
    fileBuffer = None       # type: bytearray or None
    reportBuffer = None     # type: bytearray or None


class ArchiveManager:
    """A Python API wrapper around the Glasswall Archive Manager library."""

    def __init__(self, pathToLib):

        try:
            self.cwd = os.getcwd()
            abs_path = os.path.abspath(pathToLib)
            self.lib_dir = os.path.dirname(abs_path)

            # Change working directory to lib directory to find dependencies in Windows
            os.chdir(self.lib_dir)
            self.gwArchiveLibrary = ct.cdll.LoadLibrary(abs_path)
            os.chdir(self.cwd)

        except Exception as e:
            raise Exception("Failed to load Glasswall Archive Management library. Exception: {0}".format(e.message))

    @staticmethod
    def ConvertCBufferToByteArray(ct_buffer, ct_bufferSize):

        """Converts C-Types buffer to a python bytearray

        :param ct.POINTER(ct.c_void_p) ct_buffer: C buffer
        :param ct.POINTER(ct.c_size_t) ct_bufferSize: C buffer size
        :rtype : bytearray
        """
        if ct_bufferSize.value:
            fileBuffer = (ct.c_byte * ct_bufferSize.value)()
            ct.memmove(fileBuffer, ct_buffer.value, ct_bufferSize.value)
            return bytearray(fileBuffer)
        else:
            return None

    def GwFileProtectAndReportArchive(self, inputFileBuffer, policyConfigString):
        """Extract archive and process each file within archive using the Glasswall engine.
        Repackage all files regenerated by the Glasswall engine in a new archive.

        :param bytearray inputFileBuffer: The buffer containing the file to be processed.
        :param str policyConfigString: Content management policy XML.
        :return: A result indicating the file process status along with the protected archive and log file.
        :rtype: GwMemReturnObj
        """

        self.gwArchiveLibrary.GwFileProtectAndReportArchive.argtypes = [
            ct.c_void_p,
            ct.c_size_t,
            ct.POINTER(ct.c_void_p),
            ct.POINTER(ct.c_size_t),
            ct.POINTER(ct.c_void_p),
            ct.POINTER(ct.c_size_t),
            ct.c_char_p
        ]

        # Variable initialization
        byteArrayBuffer         = bytearray(inputFileBuffer)
        ct_buffer               = (ct.c_ubyte * len(byteArrayBuffer)).from_buffer(byteArrayBuffer)
        ct_length               = ct.c_size_t(len(inputFileBuffer))
        ct_outputFileBuffer     = ct.c_void_p(0)
        ct_fileBufferSize       = ct.c_size_t(0)
        ct_outputReportBuffer   = ct.c_void_p(0)
        ct_reportBufferSize     = ct.c_size_t(0)
        ct_policyXml            = ct.c_char_p(policyConfigString.encode("utf-8"))

        # Process Archive
        gwReturn = GwMemReturnObj()

        # Archive Manager dynamically loads library so we need to make sure we are in the lib directory
        os.chdir(self.lib_dir)
        gwReturn.returnStatus = self.gwArchiveLibrary.GwFileProtectAndReportArchive(
            ct.byref(ct_buffer),
            ct_length,
            ct.byref(ct_outputFileBuffer),
            ct.byref(ct_fileBufferSize),
            ct.byref(ct_outputReportBuffer),
            ct.byref(ct_reportBufferSize),
            ct_policyXml
        )
        os.chdir(self.cwd)  # Switch back to working directory

        # Convert output to python bytearray(s)
        gwReturn.fileBuffer = self.ConvertCBufferToByteArray(ct_outputFileBuffer, ct_fileBufferSize)
        gwReturn.reportBuffer = self.ConvertCBufferToByteArray(ct_outputReportBuffer, ct_reportBufferSize)

        # Tidy up
        self.GwArchiveDone()

        return gwReturn

    def GwFileAnalysisArchive(self, inputFileBuffer, policyConfigString):
        """Extract archive and process each file within archive using the Glasswall engine.
        Repackage all files regenerated by the Glasswall engine in a new archive.

        :param bytearray inputFileBuffer: The buffer containing the file to be processed.
        :param str policyConfigString: Content management policy XML.
        :return: An object containing result indicating the file process status along with a new archive
        (containing analysis reports for each file within the the archive)
        and a summary archive report(XML).
        :rtype: GwMemReturnObj
        """

        self.gwArchiveLibrary.GwFileAnalysisArchive.argtypes = [
            ct.c_void_p,
            ct.c_size_t,
            ct.POINTER(ct.c_void_p),
            ct.POINTER(ct.c_size_t),
            ct.POINTER(ct.c_void_p),
            ct.POINTER(ct.c_size_t),
            ct.c_char_p
        ]

        # Variable initialization
        byteArrayBuffer         = bytearray(inputFileBuffer)
        ct_buffer               = (ct.c_ubyte * len(byteArrayBuffer)).from_buffer(byteArrayBuffer)
        ct_length               = ct.c_size_t(len(inputFileBuffer))
        ct_outputFileBuffer     = ct.c_void_p(0)
        ct_fileBufferSize       = ct.c_size_t(0)
        ct_outputReportBuffer   = ct.c_void_p(0)
        ct_reportBufferSize     = ct.c_size_t(0)
        ct_policyXml            = ct.c_char_p(policyConfigString.encode("utf-8"))

        # Process Archive
        gwReturn = GwMemReturnObj()
        # Archive Manager dynamically loads library so we need to make sure we are in the lib directory
        os.chdir(self.lib_dir)
        gwReturn.returnStatus = self.gwArchiveLibrary.GwFileAnalysisArchive(
            ct.byref(ct_buffer),
            ct_length,
            ct.byref(ct_outputFileBuffer),
            ct.byref(ct_fileBufferSize),
            ct.byref(ct_outputReportBuffer),
            ct.byref(ct_reportBufferSize),
            ct_policyXml
        )
        os.chdir(self.cwd)  # Switch back to working directory

        # Convert output to python bytearray(s)
        gwReturn.fileBuffer = self.ConvertCBufferToByteArray(ct_outputFileBuffer, ct_fileBufferSize)
        gwReturn.reportBuffer = self.ConvertCBufferToByteArray(ct_outputReportBuffer, ct_reportBufferSize)

        # Tidy up
        self.GwArchiveDone()

        return gwReturn

    def GwArchiveDone(self):
        """Releases any resources held by the Glasswall Archive Manager library.
        This is called once file processing is done.
        """

        # API Call - Free resources held by the archive manager library
        self.gwArchiveLibrary.GwArchiveDone()
